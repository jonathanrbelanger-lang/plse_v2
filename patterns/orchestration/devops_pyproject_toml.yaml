plse_version: "2.0"
pattern_id: "orchestration_devops_pyproject_toml"

metadata:
  author: "PLSE v2.0 Orchestration Library"
  description: |
    Generates a modern, PEP 621-compliant `pyproject.toml` file for a Python project.
    This pattern teaches the LLM how to structure a project's metadata, define its
    core dependencies, and specify optional dependencies for different environments
    like development and testing. It demonstrates the move away from legacy
    `setup.py` files to a declarative, standardized configuration.
  tags: [orchestration, devops, packaging, poetry, pdm, pyproject, toml, best-practice]
  pedagogy:
    concept: "Modern Python Project Packaging with pyproject.toml"
    difficulty: "expert"

instruction: "Write a complete `pyproject.toml` file for a Python project named `{{ project_name }}`. The file should specify the project's version, description, authors, and Python version requirement. It must also list its core runtime dependencies and include optional dependencies for a `dev` environment."

parameters:
  project_name:
    type: "string"
    description: "The name of the Python project."
    default: "my_cool_project"
  project_version:
    type: "string"
    description: "The initial version of the project."
    default: "0.1.0"
  python_version_requires:
    type: "string"
    description: "The required Python version for the project."
    default: ">=3.9"

requires: [] # The generated artifact is TOML, not Python

components:
  model_definition: |
    # This is a TOML file, not Python. It defines the project's structure and dependencies.
    # The [build-system] table is mandatory and tells tools like pip how to build the project.
    [build-system]
    requires = ["hatchling"]
    build-backend = "hatchling.build"

    # The [project] table contains all the core metadata, following PEP 621.
    [project]
    name = "{{ project_name }}"
    version = "{{ project_version }}"
    description = "A sample project generated by the PLSE v2.0 Orchestration Library."
    authors = [
      { name = "Developer Name", email = "dev@example.com" },
    ]
    readme = "README.md"
    requires-python = "{{ python_version_requires }}"
    classifiers = [
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ]

    # Core runtime dependencies are listed here.
    # These are the packages required for the project to run.
    dependencies = [
        "fastapi>=0.100.0",
        "pydantic>=2.0",
        "torch",
    ]

    # The [project.urls] table provides helpful links on the PyPI page.
    [project.urls]
    Homepage = "https://github.com/example/{{ project_name }}"
    "Bug Tracker" = "https://github.com/example/{{ project_name }}/issues"

    # The [project.optional-dependencies] table is for dependencies not needed in production.
    # Users can install these with `pip install .[dev]`.
    [project.optional-dependencies]
    dev = [
        "pytest",
        "ruff",
        "mypy",
        "uvicorn",
    ]

validation:
  linter_checks: false # Not applicable to TOML files
  unit_test_snippets:
    - |
      # This validation uses a shell command to check the TOML file's syntax.
      # We can use a modern packaging tool like `pip` or `poetry` to validate it.
      # `pip install .` in a dry-run mode or a dedicated checker is a good test.
      # For simplicity, we'll check if a basic `pip install` command can parse it.
      shell_exec: |
        pip install toml && \
        python -c "import toml; toml.loads('''{{ __raw_code__ }}''')"
