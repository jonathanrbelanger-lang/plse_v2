plse_version: "2.0"
pattern_id: "plse.meta.pattern_generator"

metadata:
  author: "PLSE v2.0 Core Library"
  description: |
    A meta-pattern that demonstrates the structure of a PLSE v2.0 YAML pattern file.
    This script uses a Python multi-line string as a template to generate the
    YAML content for a new, simple pattern. This teaches the LLM the schema for
    creating its own patterns.
  tags: [meta, plse, yaml, code-generation, best-practice]
  pedagogy:
    concept: "Schema-Conformant Code Generation"
    difficulty: "advanced"

instruction: "Write a Python script that generates the YAML definition for a new PLSE pattern. The new pattern should be for a simple concept named `{{ new_pattern_name }}` and should be saved to a file named `{{ output_filename }}`."

parameters:
  new_pattern_name:
    type: "choice"
    description: "The concept for the new pattern to be generated."
    default: "hello_world"
    constraints:
      options: ["hello_world", "simple_addition"]
  output_filename:
    type: "choice"
    description: "The name of the output YAML file."
    default: "generated_pattern.yaml"
    constraints:
      options: ["generated_pattern.yaml", "new_pattern.yml"]

requires:
  - "os"

template: |
  import os

  # --- Parameters for the new pattern we are generating ---
  PATTERN_NAME = "{{ new_pattern_name }}"
  OUTPUT_FILENAME = "{{ output_filename }}"

  # --- This multi-line string is a template for a PLSE v2.0 YAML file ---
  # It defines a simple pattern that just prints a message.
  YAML_TEMPLATE = f\"\"\"
  plse_version: "2.0"
  pattern_id: f"python.core.{PATTERN_NAME}"

  metadata:
    author: "Generated by PLSE Meta-Pattern"
    description: "A simple pattern to demonstrate printing a message."
    tags: [python, core-language, beginner]
    pedagogy:
      concept: "Basic Console Output"
      difficulty: "beginner"

  instruction: "Write a Python script that prints the message 'Hello, {PATTERN_NAME}!' to the console."

  parameters:
    message:
      type: "string"
      description: "The message to print."
      default: "Hello, {PATTERN_NAME}!"

  requires: []

  template: |
    # A very simple Python script
    message_to_print = "{{{{ message }}}}" # Use double braces to escape for the f-string
    print(message_to_print)

  validation:
    linter_checks: true
    unit_test_snippets:
      - |
        # This test would require capturing stdout, which is complex.
        # For a simple generated pattern, we can just ensure it runs.
        assert "message_to_print" in locals()
        assert message_to_print == "Hello, {PATTERN_NAME}!"
  \"\"\"

  def generate_pattern_file(filename: str, content: str):
      """Saves the generated YAML content to a file."""
      print(f"--- Generating new pattern file: {filename} ---")
      try:
          with open(filename, "w") as f:
              f.write(content)
          print(f"✅ Successfully saved new pattern.")
      except IOError as e:
          print(f"❌ Error writing file: {e}")

  if __name__ == "__main__":
      generate_pattern_file(OUTPUT_FILENAME, YAML_TEMPLATE)

validation:
  linter_checks: true
  unit_test_snippets:
    - |
      # Test the side effect of the script: file creation and content.
      import yaml
      
      # Run the generator
      generate_pattern_file(OUTPUT_FILENAME, YAML_TEMPLATE)
      
      assert os.path.exists(OUTPUT_FILENAME), "The YAML pattern file was not created."
      
      # Load the generated YAML and validate its structure
      with open(OUTPUT_FILENAME, 'r') as f:
          generated_pattern_data = yaml.safe_load(f)
      
      assert generated_pattern_data['pattern_id'] == "python.core.{{ new_pattern_name }}"
      assert "template" in generated_pattern_data
      assert "print(message_to_print)" in generated_pattern_data['template']
      
      print("Meta-pattern generator validation passed.")
      
      # Clean up
      os.remove(OUTPUT_FILENAME)