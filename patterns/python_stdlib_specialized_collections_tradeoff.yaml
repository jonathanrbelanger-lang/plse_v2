plse_version: "2.0"
pattern_id: "python_stdlib_specialized_collections_tradeoff"

metadata:
  author: "PLSE v2.0 Core Library"
  description: |
    A "tradeoff" pattern that compares three different ways to count the frequency
    of items in a list: using a standard `dict`, `collections.defaultdict`, and
    `collections.Counter`. It demonstrates the trade-off between a general-purpose
    tool and specialized, more convenient tools from the standard library, teaching
    the importance of choosing the right data structure for the task.
  tags: [python, stdlib, collections, dict, defaultdict, counter, trade-off, best-practice, readability]
  pedagogy:
    concept: "Choosing the Right Tool: General vs. Specialized Collections"
    difficulty: "intermediate"

instruction: "Write a Python script that counts the frequency of items in a list. Implement the solution in three distinct ways: 1) using a standard `dict` with manual key checks, 2) using `collections.defaultdict` to simplify the logic, and 3) using `collections.Counter` as the most direct solution. Include comments explaining the trade-offs."

parameters:
  data_list_var:
    type: "choice"
    description: "The variable name for the list of data to be counted."
    default: "data"
    constraints:
      options: ["data", "items_to_count", "log_entries"]

requires:
  - "collections"

template: |
  from collections import defaultdict, Counter

  # --- Setup: A list with repeated items to count ---
  {{ data_list_var }} = ["apple", "banana", "apple", "orange", "banana", "apple"]

  print("="*60)
  print("ANALYSIS: Comparing three methods for counting item frequency")
  print("="*60)

  # --- Method 1: Standard `dict` ---
  # This is a manual implementation. It works, but it's verbose.
  # It requires an explicit check to see if the key already exists.
  print("\\n--- Method 1: Using a standard `dict` (LBYL style) ---")
  counts_dict = {}
  for item in {{ data_list_var }}:
      if item not in counts_dict:
          counts_dict[item] = 0
      counts_dict[item] += 1
  print(f"Result: {counts_dict}")
  print("Trade-off: Most general-purpose, but requires boilerplate for default values.")

  # --- Method 2: `collections.defaultdict` ---
  # This is a more elegant and Pythonic solution for this problem.
  # The `defaultdict(int)` automatically provides a default value of 0 for
  # any key that has not yet been seen, removing the need for the `if` check.
  print("\\n--- Method 2: Using `collections.defaultdict` ---")
  counts_defaultdict = defaultdict(int)
  for item in {{ data_list_var }}:
      counts_defaultdict[item] += 1
  print(f"Result: {dict(counts_defaultdict)}") # Convert to dict for clean printing
  print("Trade-off: Cleaner and more concise than a standard dict for grouping/counting.")

  # --- Method 3: `collections.Counter` ---
  # This is the most specialized and direct tool for this specific task.
  # It is designed for counting and provides the most readable, one-line solution.
  print("\\n--- Method 3: Using `collections.Counter` ---")
  counts_counter = Counter({{ data_list_var }})
  print(f"Result: {dict(counts_counter)}")
  print("Trade-off: The perfect tool for this specific job. Less flexible for other tasks, but highly expressive for counting.")

  # --- Conclusion ---
  print("\\n--- CONCLUSION ---")
  print("While all three methods produce the same result, they represent a spectrum of specialization.")
  print("  - `dict`: Fully manual, verbose, but general.")
  print("  - `defaultdict`: Simplifies the logic for creating new entries.")
  print("  - `Counter`: The most direct, readable, and specialized tool for counting.")
  print("\\nFor simple frequency counting, `Counter` is the clear best practice.")

validation:
  linter_checks: true
  unit_test_snippets:
    - |
      # This test validates that all three methods are functionally equivalent
      # and produce the exact same final counts. This isolates the choice
      # between them to one of readability, convenience, and specialization.
      
      test_data = ['a', 'b', 'a', 'c', 'a', 'b']
      
      # Method 1
      d1 = {}
      for item in test_data:
          d1[item] = d1.get(item, 0) + 1
          
      # Method 2
      d2 = defaultdict(int)
      for item in test_data:
          d2[item] += 1
          
      # Method 3
      d3 = Counter(test_data)
      
      expected_result = {'a': 3, 'b': 2, 'c': 1}
      
      assert d1 == expected_result
      assert dict(d2) == expected_result
      assert dict(d3) == expected_result
      
      print("Tradeoff pattern validation passed: All counting methods are logically correct.")