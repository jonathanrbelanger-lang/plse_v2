plse_version: "2.0"
pattern_id: "plse_meta_paired_pattern_generator"

metadata:
  author: "PLSE v2.0 Core Library"
  description: |
    A meta-pattern that demonstrates the complete structure of a PLSE v2.0 paired
    pattern file. This script generates the YAML content for a new, simple pattern
    that uses the `is_anti_pattern` boolean flag and Jinja conditionals to produce
    both a flawed and a correct version. This teaches the LLM the schema for
    creating its own dual-purpose, pedagogical patterns.
  tags: [meta, plse, yaml, code-generation, anti-pattern, best-practice]
  pedagogy:
    concept: "Schema-Conformant Paired Pattern Generation"
    difficulty: "advanced"

instruction: "Write a Python script that generates the YAML definition for a new, paired PLSE pattern. The new pattern should demonstrate a simple concept named `{{ new_pattern_name }}` and should be saved to a file named `{{ output_filename }}`."

parameters:
  new_pattern_name:
    type: "choice"
    description: "The concept for the new paired pattern to be generated."
    default: "simple_comparison"
    constraints:
      options: ["simple_comparison", "boolean_check"]
  output_filename:
    type: "choice"
    description: "The name of the output YAML file."
    default: "generated_paired_pattern.yaml"
    constraints:
      options: ["generated_paired_pattern.yaml", "new_paired_pattern.yml"]

requires:
  - "os"
  - "yaml"

template: |
  import os

  # --- Parameters for the new pattern we are generating ---
  PATTERN_NAME = "{{ new_pattern_name }}"
  OUTPUT_FILENAME = "{{ output_filename }}"

  # --- This multi-line string is a template for a PLSE v2.0 PAIRED pattern ---
  # It demonstrates the core concepts: `is_anti_pattern` and Jinja conditionals.
  YAML_TEMPLATE = f\"\"\"
  plse_version: "2.0"
  pattern_id: f"python.anti_pattern.{PATTERN_NAME}"

  metadata:
    author: "Generated by PLSE Meta-Pattern"
    description: "A simple paired pattern demonstrating a common comparison mistake."
    tags: [python, core-language, anti-pattern, beginner]
    pedagogy:
      concept: "Correctly Checking for None"
      difficulty: "beginner"

  instruction: |
    {{ '{%' }} if is_anti_pattern {{ '%}' }}
    The following code incorrectly uses the equality operator `==` to check for `None`. Explain why using the identity operator `is` is preferred and refactor the code.
    {{ '{%' }} else {{ '%}' }}
    Write a Python script that idiomatically checks if a variable is `None` using the identity operator `is`.
    {{ '{%' }} endif {{ '%}' }}

  parameters:
    is_anti_pattern:
      type: "bool"
      description: "If true, generate the flawed code. If false, generate the corrected solution."
      default: true
    variable_name:
      type: "string"
      description: "The name of the variable to check."
      default: "my_var"

  requires: []

  template: |
    {{ '{{' }} variable_name {{ '}}' }} = None

    # The 'is' operator checks for object identity, which is the correct
    # and more performant way to check for singletons like None, True, and False.
    {{ '{%' }} if is_anti_pattern {{ '%}' }}
    # ANTI-PATTERN: Using '==' can be unreliable and slower.
    if {{ '{{' }} variable_name {{ '}}' }} == None:
        print("Variable is None (checked with ==)")
    {{ '{%' }} else {{ '%}' }}
    # CORRECT PATTERN: Use the 'is' identity operator.
    if {{ '{{' }} variable_name {{ '}}' }} is None:
        print("Variable is None (checked with is)")
    {{ '{%' }} endif {{ '%}' }}

  validation:
    linter_checks: true
    unit_test_snippets:
      - |
        # This test validates the logical outcome of the check.
        test_var = None
        result = False
        {{ '{%' }} if is_anti_pattern {{ '%}' }}
        if test_var == None:
            result = True
        {{ '{%' }} else {{ '%}' }}
        if test_var is None:
            result = True
        {{ '{%' }} endif {{ '%}' }}
        assert result, "The check for None should evaluate to True."
  \"\"\"

  def generate_pattern_file(filename: str, content: str):
      """Saves the generated YAML content to a file."""
      print(f"--- Generating new paired pattern file: {filename} ---")
      try:
          with open(filename, "w") as f:
              f.write(content)
          print(f"✅ Successfully saved new pattern.")
      except IOError as e:
          print(f"❌ Error writing file: {e}")

  if __name__ == "__main__":
      generate_pattern_file(OUTPUT_FILENAME, YAML_TEMPLATE)

validation:
  linter_checks: true
  unit_test_snippets:
    - |
      # Test the side effect of the script: file creation and content validation.
      import yaml
      
      # Run the generator
      generate_pattern_file(OUTPUT_FILENAME, YAML_TEMPLATE)
      
      assert os.path.exists(OUTPUT_FILENAME), "The YAML pattern file was not created."
      
      # Load the generated YAML and validate its structure for paired patterns
      with open(OUTPUT_FILENAME, 'r') as f:
          generated_pattern_data = yaml.safe_load(f)
      
      assert 'is_anti_pattern' in generated_pattern_data['parameters']
      assert '{% if is_anti_pattern %}' in generated_pattern_data['instruction']
      assert '{% if is_anti_pattern %}' in generated_pattern_data['template']
      
      print("Meta-pattern generator validation passed: Correctly generated a paired pattern structure.")
      
      # Clean up
      os.remove(OUTPUT_FILENAME)