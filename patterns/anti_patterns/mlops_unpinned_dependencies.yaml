plse_version: "2.0"
pattern_id: "mlops.anti_pattern.unpinned_dependencies"

metadata:
  author: "PLSE v2.0 Anti-Pattern Library"
  description: |
    Demonstrates the critical MLOps anti-pattern of using unpinned dependencies
    in a `requirements.txt` file. This paired pattern shows a fragile, abstract
    dependency file and contrasts it with a robust, pinned file generated by a
    tool like `pip freeze`, which is essential for reproducible builds.
  tags: [mlops, reproducibility, dependencies, pip, best-practice, anti-pattern]
  pedagogy:
    concept: "Deterministic Environments with Pinned Dependencies"
    difficulty: "intermediate"

instruction: "{% if is_anti_pattern %}The following `requirements.txt` file is not suitable for production because it can lead to non-reproducible environments. Explain the risks and show the corrected, pinned version.{% else %}Create a robust `requirements.txt` file that pins dependencies to exact versions to ensure deterministic builds.{% endif %}"

parameters:
  is_anti_pattern:
    type: "bool"
    description: "If true, generate the flawed file. If false, generate the corrected solution."
    default: true
  filename:
    type: "choice"
    description: "The name of the requirements file."
    default: "requirements.txt"
    constraints:
      options: ["requirements.txt", "dependencies.txt"]

requires:
  - "textwrap"
  - "re"

template: |
  import textwrap
  import re

  {% if is_anti_pattern %}
  # --- ANTI-PATTERN: Abstract, unpinned dependencies ---
  # This file is dangerous because `pip install` will grab the LATEST versions
  # of these packages, which can change over time and break the project.
  requirements_content = textwrap.dedent("""
      # Fragile requirements - DO NOT USE IN PRODUCTION
      numpy
      pandas>=1.0
      scikit-learn
  """)
  
  {% else %}
  # --- CORRECT PATTERN: Pinned, exact dependencies ---
  # This file is robust. It guarantees that `pip install` will create the
  # exact same environment every single time. This is typically generated
  # by running `pip freeze > requirements.txt`.
  requirements_content = textwrap.dedent("""
      # Robust requirements for a reproducible environment
      numpy==1.26.4
      pandas==2.2.2
      scikit-learn==1.4.2
      # ... and all transitive dependencies would also be listed
      python-dateutil==2.9.0.post0
      pytz==2024.1
      six==1.16.0
      threadpoolctl==3.5.0
      tzdata==2024.1
  """)
  {% endif %}

  # --- Save the file to disk to simulate a real project ---
  FILENAME = "{{ filename }}"
  with open(FILENAME, "w") as f:
      f.write(requirements_content.strip())

  print(f"--- Content of '{FILENAME}' ---")
  print(requirements_content.strip())

  {% if is_anti_pattern %}
  print("\\nANALYSIS: This file is not reproducible. A new version of pandas could be released tomorrow, breaking the code.")
  {% else %}
  print("\\nANALYSIS: This file is reproducible. The environment will be identical every time.")
  {% endif %}

validation:
  linter_checks: true
  unit_test_snippets:
    - |
      # This test validates the content of the generated requirements file.
      
      # Read the content of the file that was just created
      with open(FILENAME, 'r') as f:
          file_content = f.read()
      
      lines = file_content.strip().split('\\n')
      # Filter out comments
      dep_lines = [line for line in lines if line and not line.startswith('#')]
      
      {% if is_anti_pattern %}
      # For the anti-pattern, we assert that at least one dependency is NOT pinned.
      is_unpinned = any('==' not in line for line in dep_lines)
      assert is_unpinned, "Anti-pattern file should contain unpinned dependencies."
      print("Unpinned dependencies anti-pattern validated.")
      {% else %}
      # For the correct pattern, we assert that ALL dependencies ARE pinned.
      is_fully_pinned = all('==' in line for line in dep_lines)
      assert is_fully_pinned, "Correct pattern file should have all dependencies pinned with '=='."
      assert "pandas==2.2.2" in dep_lines
      print("Pinned dependencies pattern validated.")
      {% endif %}
      
      # Clean up the created file
      import os
      os.remove(FILENAME)