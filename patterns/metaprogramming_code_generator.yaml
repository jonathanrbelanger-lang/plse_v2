plse_version: "2.0"
pattern_id: "python.metaprogramming.code_generator_jinja"

metadata:
  author: "PLSE v2.0 Core Library (from DefTrinHTLCompr.ipynb)"
  description: |
    Demonstrates an advanced metaprogramming pattern: a code generator.
    This script reads a library of model definitions from a YAML file, uses a
    Jinja2 template to render a complete Python source file for each model,
    and saves them to a directory for later use.
  tags: [python, metaprogramming, code-generation, jinja2, yaml, mlops, best-practice]
  pedagogy:
    concept: "Code Generation from Configuration"
    difficulty: "advanced"

instruction: "Write a Python script that functions as a code generator. It should load model definitions from a YAML string, use a Jinja2 template to generate Python classes for each model, and save the resulting code to separate files in a '{{ output_dir }}' directory."

parameters:
  output_dir:
    type: "choice"
    description: "The directory to save the generated Python files."
    default: "generated_modules"
    constraints:
      options: ["generated_modules", "compiled_code", "model_library"]

requires:
  - "yaml"
  - "jinja2"
  - "os"
  - "textwrap"

template: |
  import yaml
  import jinja2
  import os
  import textwrap

  # --- 1. Define the Data Source (Model Library) ---
  # In a real application, this would be a separate .yml file.
  model_library_yaml = textwrap.dedent("""
  - name: "SimpleRegressor"
    type: "linear"
    parameters: ["input_features", "output_features"]
  - name: "DeepClassifier"
    type: "mlp"
    parameters: ["input_features", "hidden_layers", "num_classes"]
  """)

  # --- 2. Define the Code Generation Template ---
  # This Jinja2 template defines the structure of the Python files to be generated.
  code_template_str = textwrap.dedent("""
  # AUTOGENERATED FILE: Do not edit.
  # Model: {{ model.name }}
  
  class {{ model.name }}:
      def __init__(self, {{ model.parameters | join(', ') }}):
          print(f"Initialized {{ model.name }} (type: {{ model.type }})")
          self.params = {
              {% for p in model.parameters -%}
              "{{ p }}": {{ p }},
              {% endfor -%}
          }
  """)

  def code_generator(output_dir: str):
      """
      Loads model definitions and generates Python source files.
      """
      print(f"--- Starting Code Generator ---")
      os.makedirs(output_dir, exist_ok=True)
      
      # Load the model definitions from the YAML string
      model_definitions = yaml.safe_load(model_library_yaml)
      
      # Set up the Jinja2 environment
      template = jinja2.Template(code_template_str)
      
      # Loop through definitions and generate a file for each
      for model_def in model_definitions:
          print(f"  - Generating code for '{model_def['name']}'...")
          rendered_code = template.render(model=model_def)
          
          output_path = os.path.join(output_dir, f"{model_def['name'].lower()}.py")
          with open(output_path, 'w') as f:
              f.write(rendered_code)
      
      print(f"âœ… Code generation complete. Files saved in '{output_dir}'.")

  # --- Main Execution ---
  if __name__ == "__main__":
      code_generator("{{ output_dir }}")

validation:
  linter_checks: true
  unit_test_snippets:
    - |
      import shutil
      # Run the generator function
      output_dir = "{{ output_dir }}"
      code_generator(output_dir)
      
      # Verify that the expected files were created
      expected_file_1 = os.path.join(output_dir, "simpleregressor.py")
      expected_file_2 = os.path.join(output_dir, "deepclassifier.py")
      
      assert os.path.exists(expected_file_1), "SimpleRegressor file was not generated."
      assert os.path.exists(expected_file_2), "DeepClassifier file was not generated."
      
      # Verify the content of one of the files
      with open(expected_file_1, 'r') as f:
          content = f.read()
          assert "class SimpleRegressor" in content
          assert "'input_features': input_features" in content

      print("Code generator validation passed.")
      
      # Clean up the generated directory
      shutil.rmtree(output_dir)
