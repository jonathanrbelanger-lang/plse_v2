"""
A utility script to discover and catalog all PLSE v2.0 YAML patterns.

This tool recursively scans the 'patterns' directory, parses the metadata from
each .yaml file, and generates a human-readable catalog.

Usage:
  - python scripts/list_patterns.py (Prints to console)
  - python scripts/list_patterns.py --output-markdown (Generates AVAILABLE_PATTERNS.md)
"""

import os
import yaml
import argparse
from collections import defaultdict

PATTERNS_DIR = "patterns"
OUTPUT_FILENAME = "AVAILABLE_PATTERNS.md"

def discover_patterns():
    """
    Recursively finds all pattern files and extracts their metadata.
    Returns a dictionary grouped by sub-directory.
    """
    categorized_patterns = defaultdict(list)
    
    if not os.path.isdir(PATTERNS_DIR):
        print(f"Error: Directory '{PATTERNS_DIR}' not found.")
        return None

    for root, _, files in os.walk(PATTERNS_DIR):
        for filename in files:
            if filename.endswith((".yaml", ".yml")):
                file_path = os.path.join(root, filename)
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        data = yaml.safe_load(f)
                    
                    pattern_id = data.get("pattern_id", "N/A")
                    description = data.get("metadata", {}).get("description", "No description.").strip().split('\n')[0]
                    
                    # Determine category from the directory path
                    relative_path = os.path.relpath(root, PATTERNS_DIR)
                    category = relative_path if relative_path != '.' else 'general'
                    
                    categorized_patterns[category].append({
                        "id": pattern_id,
                        "description": description
                    })
                except Exception as e:
                    print(f"Warning: Could not process file '{file_path}': {e}")
    
    # Sort patterns within each category
    for category in categorized_patterns:
        categorized_patterns[category].sort(key=lambda p: p['id'])
        
    return categorized_patterns

def print_to_console(categorized_patterns):
    """Prints a formatted list of patterns to the console."""
    print("="*80)
    print("‚úÖ AVAILABLE PLSE v2.0 PATTERNS")
    print("="*80)
    
    for category, patterns in sorted(categorized_patterns.items()):
        print(f"\nüìÅ Category: {category}")
        print("-" * (len(category) + 12))
        for pattern in patterns:
            print(f"  - {pattern['id']}: {pattern['description']}")
    print("\n")

def write_to_markdown(categorized_patterns, output_file):
    """Writes the catalog to a Markdown file."""
    print(f"Generating Markdown catalog at '{output_file}'...")
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# PLSE v2.0 Available Patterns\n\n")
        f.write("This file is auto-generated by `scripts/list_patterns.py`. Do not edit manually.\n\n")
        
        for category, patterns in sorted(categorized_patterns.items()):
            f.write(f"## üìÅ {category.replace('_', ' ').title()}\n\n")
            for pattern in patterns:
                f.write(f"- **`{pattern['id']}`**: {pattern['description']}\n")
            f.write("\n")
    print(f"‚úÖ Successfully generated '{output_file}'.")

def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(description="Discover and catalog PLSE v2.0 patterns.")
    parser.add_argument(
        '--output-markdown',
        action='store_true',
        help=f"Generate a '{OUTPUT_FILENAME}' file instead of printing to the console."
    )
    args = parser.parse_args()
    
    patterns = discover_patterns()
    if not patterns:
        return
        
    if args.output_markdown:
        write_to_markdown(patterns, OUTPUT_FILENAME)
    else:
        print_to_console(patterns)

if __name__ == "__main__":
    main()
